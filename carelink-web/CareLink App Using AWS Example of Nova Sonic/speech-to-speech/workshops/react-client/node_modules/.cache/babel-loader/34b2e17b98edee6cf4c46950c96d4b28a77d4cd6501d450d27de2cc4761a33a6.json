{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useEffect, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { getFirstFocusable } from '../focus-lock/utils';\nimport Tooltip from '../tooltip';\nimport DirectionButton from './direction-button';\nimport PortalOverlay from './portal-overlay';\nimport styles from './styles.css.js';\n// The amount of distance after pointer down that the cursor is allowed to\n// jitter for a subsequent mouseup to still register as a \"press\" instead of\n// a drag. A little allowance is needed for usability reasons, but this number\n// isn't set in stone.\nconst PRESS_DELTA_MAX = 3;\nexport default function DragHandleWrapper({\n  directions,\n  tooltipText,\n  children,\n  onDirectionClick\n}) {\n  const wrapperRef = useRef(null);\n  const dragHandleRef = useRef(null);\n  const [showTooltip, setShowTooltip] = useState(false);\n  const [showButtons, setShowButtons] = useState(false);\n  // The tooltip (\"Drag or select to move/resize\") shouldn't show if clicking\n  // on the handle wouldn't do anything.\n  const isDisabled = !directions['block-start'] && !directions['block-end'] && !directions['inline-start'] && !directions['inline-end'];\n  const onWrapperFocusIn = event => {\n    // The drag handle is focused when it's either tabbed to, or the pointer\n    // is pressed on it. We exclude handling the pointer press in this handler,\n    // since it could be the start of a drag event - the pointer stuff is\n    // handled in the \"pointerup\" listener instead.\n    if (!isPointerDown.current && !nodeContains(wrapperRef.current, event.relatedTarget)) {\n      setShowTooltip(false);\n      setShowButtons(true);\n    }\n  };\n  const onWrapperFocusOut = event => {\n    // Close the directional buttons when the focus leaves the drag handle.\n    // \"focusout\" is also triggered when the user leaves the current tab, but\n    // since it'll be returned when they switch back anyway, we exclude that\n    // case by checking for `document.hasFocus()`.\n    if (document.hasFocus() && !nodeContains(wrapperRef.current, event.relatedTarget)) {\n      setShowButtons(false);\n    }\n  };\n  const isPointerDown = useRef(false);\n  const initialPointerPosition = useRef();\n  const didPointerDrag = useRef(false);\n  useEffect(() => {\n    const controller = new AbortController();\n    // See `PRESS_DELTA_MAX` above. We need to differentiate between a \"click\"\n    // and a \"drag\" action. We can say a \"click\" happens when a \"pointerdown\"\n    // is followed by a \"pointerup\" with no \"pointermove\" between the two.\n    // However, it would be a poor usability experience if a \"click\" isn't\n    // registered because, while pressing my mouse, I moved it by just one\n    // pixel, making it a \"drag\" instead. So we allow the pointer to move by\n    // `PRESS_DELTA_MAX` pixels before setting `didPointerDrag` to true.\n    document.addEventListener('pointermove', event => {\n      if (isPointerDown.current && initialPointerPosition.current && (event.clientX > initialPointerPosition.current.x + PRESS_DELTA_MAX || event.clientX < initialPointerPosition.current.x - PRESS_DELTA_MAX || event.clientY > initialPointerPosition.current.y + PRESS_DELTA_MAX || event.clientY < initialPointerPosition.current.y - PRESS_DELTA_MAX)) {\n        didPointerDrag.current = true;\n      }\n    }, {\n      signal: controller.signal\n    });\n    // Shared behavior when a \"pointerdown\" state ends. This is shared so it\n    // can be called for both \"pointercancel\" and \"pointerup\" events.\n    const resetPointerDownState = () => {\n      isPointerDown.current = false;\n      initialPointerPosition.current = undefined;\n    };\n    document.addEventListener('pointercancel', () => {\n      resetPointerDownState();\n    }, {\n      signal: controller.signal\n    });\n    document.addEventListener('pointerup', () => {\n      if (isPointerDown.current && !didPointerDrag.current) {\n        // The cursor didn't move much between \"pointerdown\" and \"pointerup\".\n        // Handle this as a \"click\" instead of a \"drag\".\n        setShowButtons(true);\n      }\n      resetPointerDownState();\n    }, {\n      signal: controller.signal\n    });\n    return () => controller.abort();\n  }, []);\n  const onHandlePointerDown = event => {\n    // Tooltip behavior: the tooltip should appear on hover, but disappear when\n    // the pointer starts dragging (having the tooltip get in the way while\n    // you're trying to drag upwards is annoying). Additionally, the tooltip\n    // shouldn't reappear when dragging ends, but only when the pointer leaves\n    // the drag handle and comes back.\n    isPointerDown.current = true;\n    didPointerDrag.current = false;\n    initialPointerPosition.current = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    setShowTooltip(false);\n  };\n  // Tooltip behavior: the tooltip should stay open when the cursor moves\n  // from the drag handle into the tooltip content itself. This is why the\n  // handler is set on the wrapper for both the drag handle and the tooltip.\n  const onTooltipGroupPointerEnter = () => {\n    if (!isPointerDown.current) {\n      setShowTooltip(true);\n    }\n  };\n  const onTooltipGroupPointerLeave = () => {\n    setShowTooltip(false);\n  };\n  const onDragHandleKeyDown = event => {\n    // For accessibility reasons, pressing escape should should always close\n    // the floating controls.\n    if (event.key === 'Escape') {\n      setShowButtons(false);\n    } else {\n      // Pressing any other key will display the focus-visible ring around the\n      // drag handle if it's in focus, so we should also show the buttons now.\n      setShowButtons(true);\n    }\n  };\n  const onInternalDirectionClick = direction => {\n    var _a;\n    // Move focus back to the wrapper on click. This prevents focus from staying\n    // on an aria-hidden control, and allows future keyboard events to be handled\n    // cleanly using the drag handle's own handlers.\n    if (dragHandleRef.current) {\n      (_a = getFirstFocusable(dragHandleRef.current)) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n    onDirectionClick === null || onDirectionClick === void 0 ? void 0 : onDirectionClick(direction);\n  };\n  return React.createElement(\"div\", {\n    className: clsx(styles['drag-handle-wrapper'], showButtons && styles['drag-handle-wrapper-open']),\n    ref: wrapperRef,\n    onFocus: onWrapperFocusIn,\n    onBlur: onWrapperFocusOut\n  }, React.createElement(\"div\", {\n    onPointerEnter: onTooltipGroupPointerEnter,\n    onPointerLeave: onTooltipGroupPointerLeave\n  }, React.createElement(\"div\", {\n    className: styles['drag-handle'],\n    ref: dragHandleRef,\n    onPointerDown: onHandlePointerDown,\n    onKeyDown: onDragHandleKeyDown\n  }, children), !isDisabled && !showButtons && showTooltip && tooltipText && React.createElement(Tooltip, {\n    trackRef: dragHandleRef,\n    value: tooltipText,\n    onDismiss: () => setShowTooltip(false)\n  })), React.createElement(PortalOverlay, {\n    track: dragHandleRef.current,\n    isDisabled: !showButtons\n  }, directions['block-start'] && React.createElement(DirectionButton, {\n    show: !isDisabled && showButtons,\n    direction: \"block-start\",\n    state: directions['block-start'],\n    onClick: () => onInternalDirectionClick('block-start')\n  }), directions['block-end'] && React.createElement(DirectionButton, {\n    show: !isDisabled && showButtons,\n    direction: \"block-end\",\n    state: directions['block-end'],\n    onClick: () => onInternalDirectionClick('block-end')\n  }), directions['inline-start'] && React.createElement(DirectionButton, {\n    show: !isDisabled && showButtons,\n    direction: \"inline-start\",\n    state: directions['inline-start'],\n    onClick: () => onInternalDirectionClick('inline-start')\n  }), directions['inline-end'] && React.createElement(DirectionButton, {\n    show: !isDisabled && showButtons,\n    direction: \"inline-end\",\n    state: directions['inline-end'],\n    onClick: () => onInternalDirectionClick('inline-end')\n  })));\n}","map":{"version":3,"names":["React","useEffect","useRef","useState","clsx","nodeContains","getFirstFocusable","Tooltip","DirectionButton","PortalOverlay","styles","PRESS_DELTA_MAX","DragHandleWrapper","directions","tooltipText","children","onDirectionClick","wrapperRef","dragHandleRef","showTooltip","setShowTooltip","showButtons","setShowButtons","isDisabled","onWrapperFocusIn","event","isPointerDown","current","relatedTarget","onWrapperFocusOut","document","hasFocus","initialPointerPosition","didPointerDrag","controller","AbortController","addEventListener","clientX","x","clientY","y","signal","resetPointerDownState","undefined","abort","onHandlePointerDown","onTooltipGroupPointerEnter","onTooltipGroupPointerLeave","onDragHandleKeyDown","key","onInternalDirectionClick","direction","_a","focus","createElement","className","ref","onFocus","onBlur","onPointerEnter","onPointerLeave","onPointerDown","onKeyDown","trackRef","value","onDismiss","track","show","state","onClick"],"sources":["/Users/jonathanfox/Desktop/amazon-nova-samples/speech-to-speech/workshops/react-client/node_modules/src/internal/components/drag-handle-wrapper/index.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useEffect, useRef, useState } from 'react';\nimport clsx from 'clsx';\n\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\n\nimport { getFirstFocusable } from '../focus-lock/utils';\nimport Tooltip from '../tooltip';\nimport DirectionButton from './direction-button';\nimport { Direction, DragHandleWrapperProps } from './interfaces';\nimport PortalOverlay from './portal-overlay';\n\nimport styles from './styles.css.js';\n\n// The amount of distance after pointer down that the cursor is allowed to\n// jitter for a subsequent mouseup to still register as a \"press\" instead of\n// a drag. A little allowance is needed for usability reasons, but this number\n// isn't set in stone.\nconst PRESS_DELTA_MAX = 3;\n\nexport default function DragHandleWrapper({\n  directions,\n  tooltipText,\n  children,\n  onDirectionClick,\n}: DragHandleWrapperProps) {\n  const wrapperRef = useRef<HTMLDivElement | null>(null);\n\n  const dragHandleRef = useRef<HTMLDivElement | null>(null);\n  const [showTooltip, setShowTooltip] = useState(false);\n  const [showButtons, setShowButtons] = useState(false);\n\n  // The tooltip (\"Drag or select to move/resize\") shouldn't show if clicking\n  // on the handle wouldn't do anything.\n  const isDisabled =\n    !directions['block-start'] && !directions['block-end'] && !directions['inline-start'] && !directions['inline-end'];\n\n  const onWrapperFocusIn: React.FocusEventHandler = event => {\n    // The drag handle is focused when it's either tabbed to, or the pointer\n    // is pressed on it. We exclude handling the pointer press in this handler,\n    // since it could be the start of a drag event - the pointer stuff is\n    // handled in the \"pointerup\" listener instead.\n    if (!isPointerDown.current && !nodeContains(wrapperRef.current, event.relatedTarget)) {\n      setShowTooltip(false);\n      setShowButtons(true);\n    }\n  };\n\n  const onWrapperFocusOut: React.FocusEventHandler = event => {\n    // Close the directional buttons when the focus leaves the drag handle.\n    // \"focusout\" is also triggered when the user leaves the current tab, but\n    // since it'll be returned when they switch back anyway, we exclude that\n    // case by checking for `document.hasFocus()`.\n    if (document.hasFocus() && !nodeContains(wrapperRef.current, event.relatedTarget)) {\n      setShowButtons(false);\n    }\n  };\n\n  const isPointerDown = useRef(false);\n  const initialPointerPosition = useRef<{ x: number; y: number } | undefined>();\n  const didPointerDrag = useRef(false);\n\n  useEffect(() => {\n    const controller = new AbortController();\n\n    // See `PRESS_DELTA_MAX` above. We need to differentiate between a \"click\"\n    // and a \"drag\" action. We can say a \"click\" happens when a \"pointerdown\"\n    // is followed by a \"pointerup\" with no \"pointermove\" between the two.\n    // However, it would be a poor usability experience if a \"click\" isn't\n    // registered because, while pressing my mouse, I moved it by just one\n    // pixel, making it a \"drag\" instead. So we allow the pointer to move by\n    // `PRESS_DELTA_MAX` pixels before setting `didPointerDrag` to true.\n    document.addEventListener(\n      'pointermove',\n      event => {\n        if (\n          isPointerDown.current &&\n          initialPointerPosition.current &&\n          (event.clientX > initialPointerPosition.current.x + PRESS_DELTA_MAX ||\n            event.clientX < initialPointerPosition.current.x - PRESS_DELTA_MAX ||\n            event.clientY > initialPointerPosition.current.y + PRESS_DELTA_MAX ||\n            event.clientY < initialPointerPosition.current.y - PRESS_DELTA_MAX)\n        ) {\n          didPointerDrag.current = true;\n        }\n      },\n      { signal: controller.signal }\n    );\n\n    // Shared behavior when a \"pointerdown\" state ends. This is shared so it\n    // can be called for both \"pointercancel\" and \"pointerup\" events.\n    const resetPointerDownState = () => {\n      isPointerDown.current = false;\n      initialPointerPosition.current = undefined;\n    };\n\n    document.addEventListener(\n      'pointercancel',\n      () => {\n        resetPointerDownState();\n      },\n      { signal: controller.signal }\n    );\n\n    document.addEventListener(\n      'pointerup',\n      () => {\n        if (isPointerDown.current && !didPointerDrag.current) {\n          // The cursor didn't move much between \"pointerdown\" and \"pointerup\".\n          // Handle this as a \"click\" instead of a \"drag\".\n          setShowButtons(true);\n        }\n        resetPointerDownState();\n      },\n      { signal: controller.signal }\n    );\n\n    return () => controller.abort();\n  }, []);\n\n  const onHandlePointerDown: React.PointerEventHandler = event => {\n    // Tooltip behavior: the tooltip should appear on hover, but disappear when\n    // the pointer starts dragging (having the tooltip get in the way while\n    // you're trying to drag upwards is annoying). Additionally, the tooltip\n    // shouldn't reappear when dragging ends, but only when the pointer leaves\n    // the drag handle and comes back.\n\n    isPointerDown.current = true;\n    didPointerDrag.current = false;\n    initialPointerPosition.current = { x: event.clientX, y: event.clientY };\n    setShowTooltip(false);\n  };\n\n  // Tooltip behavior: the tooltip should stay open when the cursor moves\n  // from the drag handle into the tooltip content itself. This is why the\n  // handler is set on the wrapper for both the drag handle and the tooltip.\n  const onTooltipGroupPointerEnter: React.PointerEventHandler = () => {\n    if (!isPointerDown.current) {\n      setShowTooltip(true);\n    }\n  };\n  const onTooltipGroupPointerLeave: React.PointerEventHandler = () => {\n    setShowTooltip(false);\n  };\n\n  const onDragHandleKeyDown: React.KeyboardEventHandler = event => {\n    // For accessibility reasons, pressing escape should should always close\n    // the floating controls.\n    if (event.key === 'Escape') {\n      setShowButtons(false);\n    } else {\n      // Pressing any other key will display the focus-visible ring around the\n      // drag handle if it's in focus, so we should also show the buttons now.\n      setShowButtons(true);\n    }\n  };\n\n  const onInternalDirectionClick = (direction: Direction) => {\n    // Move focus back to the wrapper on click. This prevents focus from staying\n    // on an aria-hidden control, and allows future keyboard events to be handled\n    // cleanly using the drag handle's own handlers.\n    if (dragHandleRef.current) {\n      getFirstFocusable(dragHandleRef.current)?.focus();\n    }\n    onDirectionClick?.(direction);\n  };\n\n  return (\n    <div\n      className={clsx(styles['drag-handle-wrapper'], showButtons && styles['drag-handle-wrapper-open'])}\n      ref={wrapperRef}\n      onFocus={onWrapperFocusIn}\n      onBlur={onWrapperFocusOut}\n    >\n      <div onPointerEnter={onTooltipGroupPointerEnter} onPointerLeave={onTooltipGroupPointerLeave}>\n        <div\n          className={styles['drag-handle']}\n          ref={dragHandleRef}\n          onPointerDown={onHandlePointerDown}\n          onKeyDown={onDragHandleKeyDown}\n        >\n          {children}\n        </div>\n\n        {!isDisabled && !showButtons && showTooltip && tooltipText && (\n          <Tooltip trackRef={dragHandleRef} value={tooltipText} onDismiss={() => setShowTooltip(false)} />\n        )}\n      </div>\n\n      <PortalOverlay track={dragHandleRef.current} isDisabled={!showButtons}>\n        {directions['block-start'] && (\n          <DirectionButton\n            show={!isDisabled && showButtons}\n            direction=\"block-start\"\n            state={directions['block-start']}\n            onClick={() => onInternalDirectionClick('block-start')}\n          />\n        )}\n        {directions['block-end'] && (\n          <DirectionButton\n            show={!isDisabled && showButtons}\n            direction=\"block-end\"\n            state={directions['block-end']}\n            onClick={() => onInternalDirectionClick('block-end')}\n          />\n        )}\n        {directions['inline-start'] && (\n          <DirectionButton\n            show={!isDisabled && showButtons}\n            direction=\"inline-start\"\n            state={directions['inline-start']}\n            onClick={() => onInternalDirectionClick('inline-start')}\n          />\n        )}\n        {directions['inline-end'] && (\n          <DirectionButton\n            show={!isDisabled && showButtons}\n            direction=\"inline-end\"\n            state={directions['inline-end']}\n            onClick={() => onInternalDirectionClick('inline-end')}\n          />\n        )}\n      </PortalOverlay>\n    </div>\n  );\n}\n"],"mappings":"AAAA;AACA;AAEA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAC1D,OAAOC,IAAI,MAAM,MAAM;AAEvB,SAASC,YAAY,QAAQ,0CAA0C;AAEvE,SAASC,iBAAiB,QAAQ,qBAAqB;AACvD,OAAOC,OAAO,MAAM,YAAY;AAChC,OAAOC,eAAe,MAAM,oBAAoB;AAEhD,OAAOC,aAAa,MAAM,kBAAkB;AAE5C,OAAOC,MAAM,MAAM,iBAAiB;AAEpC;AACA;AACA;AACA;AACA,MAAMC,eAAe,GAAG,CAAC;AAEzB,eAAc,SAAUC,iBAAiBA,CAAC;EACxCC,UAAU;EACVC,WAAW;EACXC,QAAQ;EACRC;AAAgB,CACO;EACvB,MAAMC,UAAU,GAAGf,MAAM,CAAwB,IAAI,CAAC;EAEtD,MAAMgB,aAAa,GAAGhB,MAAM,CAAwB,IAAI,CAAC;EACzD,MAAM,CAACiB,WAAW,EAAEC,cAAc,CAAC,GAAGjB,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACkB,WAAW,EAAEC,cAAc,CAAC,GAAGnB,QAAQ,CAAC,KAAK,CAAC;EAErD;EACA;EACA,MAAMoB,UAAU,GACd,CAACV,UAAU,CAAC,aAAa,CAAC,IAAI,CAACA,UAAU,CAAC,WAAW,CAAC,IAAI,CAACA,UAAU,CAAC,cAAc,CAAC,IAAI,CAACA,UAAU,CAAC,YAAY,CAAC;EAEpH,MAAMW,gBAAgB,GAA4BC,KAAK,IAAG;IACxD;IACA;IACA;IACA;IACA,IAAI,CAACC,aAAa,CAACC,OAAO,IAAI,CAACtB,YAAY,CAACY,UAAU,CAACU,OAAO,EAAEF,KAAK,CAACG,aAAa,CAAC,EAAE;MACpFR,cAAc,CAAC,KAAK,CAAC;MACrBE,cAAc,CAAC,IAAI,CAAC;;EAExB,CAAC;EAED,MAAMO,iBAAiB,GAA4BJ,KAAK,IAAG;IACzD;IACA;IACA;IACA;IACA,IAAIK,QAAQ,CAACC,QAAQ,EAAE,IAAI,CAAC1B,YAAY,CAACY,UAAU,CAACU,OAAO,EAAEF,KAAK,CAACG,aAAa,CAAC,EAAE;MACjFN,cAAc,CAAC,KAAK,CAAC;;EAEzB,CAAC;EAED,MAAMI,aAAa,GAAGxB,MAAM,CAAC,KAAK,CAAC;EACnC,MAAM8B,sBAAsB,GAAG9B,MAAM,EAAwC;EAC7E,MAAM+B,cAAc,GAAG/B,MAAM,CAAC,KAAK,CAAC;EAEpCD,SAAS,CAAC,MAAK;IACb,MAAMiC,UAAU,GAAG,IAAIC,eAAe,EAAE;IAExC;IACA;IACA;IACA;IACA;IACA;IACA;IACAL,QAAQ,CAACM,gBAAgB,CACvB,aAAa,EACbX,KAAK,IAAG;MACN,IACEC,aAAa,CAACC,OAAO,IACrBK,sBAAsB,CAACL,OAAO,KAC7BF,KAAK,CAACY,OAAO,GAAGL,sBAAsB,CAACL,OAAO,CAACW,CAAC,GAAG3B,eAAe,IACjEc,KAAK,CAACY,OAAO,GAAGL,sBAAsB,CAACL,OAAO,CAACW,CAAC,GAAG3B,eAAe,IAClEc,KAAK,CAACc,OAAO,GAAGP,sBAAsB,CAACL,OAAO,CAACa,CAAC,GAAG7B,eAAe,IAClEc,KAAK,CAACc,OAAO,GAAGP,sBAAsB,CAACL,OAAO,CAACa,CAAC,GAAG7B,eAAe,CAAC,EACrE;QACAsB,cAAc,CAACN,OAAO,GAAG,IAAI;;IAEjC,CAAC,EACD;MAAEc,MAAM,EAAEP,UAAU,CAACO;IAAM,CAAE,CAC9B;IAED;IACA;IACA,MAAMC,qBAAqB,GAAGA,CAAA,KAAK;MACjChB,aAAa,CAACC,OAAO,GAAG,KAAK;MAC7BK,sBAAsB,CAACL,OAAO,GAAGgB,SAAS;IAC5C,CAAC;IAEDb,QAAQ,CAACM,gBAAgB,CACvB,eAAe,EACf,MAAK;MACHM,qBAAqB,EAAE;IACzB,CAAC,EACD;MAAED,MAAM,EAAEP,UAAU,CAACO;IAAM,CAAE,CAC9B;IAEDX,QAAQ,CAACM,gBAAgB,CACvB,WAAW,EACX,MAAK;MACH,IAAIV,aAAa,CAACC,OAAO,IAAI,CAACM,cAAc,CAACN,OAAO,EAAE;QACpD;QACA;QACAL,cAAc,CAAC,IAAI,CAAC;;MAEtBoB,qBAAqB,EAAE;IACzB,CAAC,EACD;MAAED,MAAM,EAAEP,UAAU,CAACO;IAAM,CAAE,CAC9B;IAED,OAAO,MAAMP,UAAU,CAACU,KAAK,EAAE;EACjC,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMC,mBAAmB,GAA8BpB,KAAK,IAAG;IAC7D;IACA;IACA;IACA;IACA;IAEAC,aAAa,CAACC,OAAO,GAAG,IAAI;IAC5BM,cAAc,CAACN,OAAO,GAAG,KAAK;IAC9BK,sBAAsB,CAACL,OAAO,GAAG;MAAEW,CAAC,EAAEb,KAAK,CAACY,OAAO;MAAEG,CAAC,EAAEf,KAAK,CAACc;IAAO,CAAE;IACvEnB,cAAc,CAAC,KAAK,CAAC;EACvB,CAAC;EAED;EACA;EACA;EACA,MAAM0B,0BAA0B,GAA8BA,CAAA,KAAK;IACjE,IAAI,CAACpB,aAAa,CAACC,OAAO,EAAE;MAC1BP,cAAc,CAAC,IAAI,CAAC;;EAExB,CAAC;EACD,MAAM2B,0BAA0B,GAA8BA,CAAA,KAAK;IACjE3B,cAAc,CAAC,KAAK,CAAC;EACvB,CAAC;EAED,MAAM4B,mBAAmB,GAA+BvB,KAAK,IAAG;IAC9D;IACA;IACA,IAAIA,KAAK,CAACwB,GAAG,KAAK,QAAQ,EAAE;MAC1B3B,cAAc,CAAC,KAAK,CAAC;KACtB,MAAM;MACL;MACA;MACAA,cAAc,CAAC,IAAI,CAAC;;EAExB,CAAC;EAED,MAAM4B,wBAAwB,GAAIC,SAAoB,IAAI;;IACxD;IACA;IACA;IACA,IAAIjC,aAAa,CAACS,OAAO,EAAE;MACzB,CAAAyB,EAAA,GAAA9C,iBAAiB,CAACY,aAAa,CAACS,OAAO,CAAC,cAAAyB,EAAA,uBAAAA,EAAA,CAAEC,KAAK,EAAE;;IAEnDrC,gBAAgB,aAAhBA,gBAAgB,uBAAhBA,gBAAgB,CAAGmC,SAAS,CAAC;EAC/B,CAAC;EAED,OACEnD,KAAA,CAAAsD,aAAA;IACEC,SAAS,EAAEnD,IAAI,CAACM,MAAM,CAAC,qBAAqB,CAAC,EAAEW,WAAW,IAAIX,MAAM,CAAC,0BAA0B,CAAC,CAAC;IACjG8C,GAAG,EAAEvC,UAAU;IACfwC,OAAO,EAAEjC,gBAAgB;IACzBkC,MAAM,EAAE7B;EAAiB,GAEzB7B,KAAA,CAAAsD,aAAA;IAAKK,cAAc,EAAEb,0BAA0B;IAAEc,cAAc,EAAEb;EAA0B,GACzF/C,KAAA,CAAAsD,aAAA;IACEC,SAAS,EAAE7C,MAAM,CAAC,aAAa,CAAC;IAChC8C,GAAG,EAAEtC,aAAa;IAClB2C,aAAa,EAAEhB,mBAAmB;IAClCiB,SAAS,EAAEd;EAAmB,GAE7BjC,QAAQ,CACL,EAEL,CAACQ,UAAU,IAAI,CAACF,WAAW,IAAIF,WAAW,IAAIL,WAAW,IACxDd,KAAA,CAAAsD,aAAA,CAAC/C,OAAO;IAACwD,QAAQ,EAAE7C,aAAa;IAAE8C,KAAK,EAAElD,WAAW;IAAEmD,SAAS,EAAEA,CAAA,KAAM7C,cAAc,CAAC,KAAK;EAAC,EAC7F,CACG,EAENpB,KAAA,CAAAsD,aAAA,CAAC7C,aAAa;IAACyD,KAAK,EAAEhD,aAAa,CAACS,OAAO;IAAEJ,UAAU,EAAE,CAACF;EAAW,GAClER,UAAU,CAAC,aAAa,CAAC,IACxBb,KAAA,CAAAsD,aAAA,CAAC9C,eAAe;IACd2D,IAAI,EAAE,CAAC5C,UAAU,IAAIF,WAAW;IAChC8B,SAAS,EAAC,aAAa;IACvBiB,KAAK,EAAEvD,UAAU,CAAC,aAAa,CAAC;IAChCwD,OAAO,EAAEA,CAAA,KAAMnB,wBAAwB,CAAC,aAAa;EAAC,EAEzD,EACArC,UAAU,CAAC,WAAW,CAAC,IACtBb,KAAA,CAAAsD,aAAA,CAAC9C,eAAe;IACd2D,IAAI,EAAE,CAAC5C,UAAU,IAAIF,WAAW;IAChC8B,SAAS,EAAC,WAAW;IACrBiB,KAAK,EAAEvD,UAAU,CAAC,WAAW,CAAC;IAC9BwD,OAAO,EAAEA,CAAA,KAAMnB,wBAAwB,CAAC,WAAW;EAAC,EAEvD,EACArC,UAAU,CAAC,cAAc,CAAC,IACzBb,KAAA,CAAAsD,aAAA,CAAC9C,eAAe;IACd2D,IAAI,EAAE,CAAC5C,UAAU,IAAIF,WAAW;IAChC8B,SAAS,EAAC,cAAc;IACxBiB,KAAK,EAAEvD,UAAU,CAAC,cAAc,CAAC;IACjCwD,OAAO,EAAEA,CAAA,KAAMnB,wBAAwB,CAAC,cAAc;EAAC,EAE1D,EACArC,UAAU,CAAC,YAAY,CAAC,IACvBb,KAAA,CAAAsD,aAAA,CAAC9C,eAAe;IACd2D,IAAI,EAAE,CAAC5C,UAAU,IAAIF,WAAW;IAChC8B,SAAS,EAAC,YAAY;IACtBiB,KAAK,EAAEvD,UAAU,CAAC,YAAY,CAAC;IAC/BwD,OAAO,EAAEA,CAAA,KAAMnB,wBAAwB,CAAC,YAAY;EAAC,EAExD,CACa,CACZ;AAEV","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}