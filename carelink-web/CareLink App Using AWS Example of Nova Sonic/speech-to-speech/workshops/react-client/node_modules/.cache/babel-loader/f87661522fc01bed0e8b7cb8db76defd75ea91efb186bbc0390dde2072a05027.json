{"ast":null,"code":"function base64LPCM(base64String) {\n  // Decode Base64 string to raw LPCM bytes\n  const byteCharacters = atob(base64String);\n  const byteArrays = new Uint8Array(byteCharacters.length);\n  for (let i = 0; i < byteCharacters.length; i++) {\n    byteArrays[i] = byteCharacters.charCodeAt(i);\n  }\n\n  // Construct WAV header (similar to your Python function)\n  const sampleRate = 24000; // 24kHz\n  const numChannels = 1; // Mono\n  const bitsPerSample = 16;\n  const byteRate = sampleRate * numChannels * (bitsPerSample / 8);\n  const blockAlign = numChannels * (bitsPerSample / 8);\n  const wavSize = byteArrays.length + 36;\n\n  // Create the WAV header\n  const wavHeader = new Uint8Array(44);\n  const view = new DataView(wavHeader.buffer);\n\n  // RIFF header\n  let offset = 0;\n  for (let i = 0; i < 4; i++) view.setUint8(offset++, \"RIFF\".charCodeAt(i));\n  view.setUint32(offset, wavSize, true);\n  offset += 4;\n  for (let i = 0; i < 4; i++) view.setUint8(offset++, \"WAVE\".charCodeAt(i));\n\n  // fmt chunk\n  for (let i = 0; i < 4; i++) view.setUint8(offset++, \"fmt \".charCodeAt(i));\n  view.setUint32(offset, 16, true);\n  offset += 4; // Subchunk1Size (16 for PCM)\n  view.setUint16(offset, 1, true);\n  offset += 2; // AudioFormat (1 for PCM)\n  view.setUint16(offset, numChannels, true);\n  offset += 2; // NumChannels\n  view.setUint32(offset, sampleRate, true);\n  offset += 4; // SampleRate\n  view.setUint32(offset, byteRate, true);\n  offset += 4; // ByteRate\n  view.setUint16(offset, blockAlign, true);\n  offset += 2; // BlockAlign\n  view.setUint16(offset, bitsPerSample, true);\n  offset += 2; // BitsPerSample\n\n  // data chunk\n  for (let i = 0; i < 4; i++) view.setUint8(offset++, \"data\".charCodeAt(i));\n  view.setUint32(offset, byteArrays.length, true);\n  offset += 4;\n\n  // Combine WAV header and raw audio data\n  const wavBlob = new Blob([wavHeader, byteArrays], {\n    type: \"audio/wav\"\n  });\n  const audioUrl = URL.createObjectURL(wavBlob);\n  return audioUrl;\n}\nexport { base64LPCM };","map":{"version":3,"names":["base64LPCM","base64String","byteCharacters","atob","byteArrays","Uint8Array","length","i","charCodeAt","sampleRate","numChannels","bitsPerSample","byteRate","blockAlign","wavSize","wavHeader","view","DataView","buffer","offset","setUint8","setUint32","setUint16","wavBlob","Blob","type","audioUrl","URL","createObjectURL"],"sources":["/Users/jonathanfox/Desktop/amazon-nova-samples/speech-to-speech/workshops/react-client/src/helper/audioHelper.js"],"sourcesContent":["function base64LPCM(base64String) {\n    // Decode Base64 string to raw LPCM bytes\n    const byteCharacters = atob(base64String);\n    const byteArrays = new Uint8Array(byteCharacters.length);\n    \n    for (let i = 0; i < byteCharacters.length; i++) {\n        byteArrays[i] = byteCharacters.charCodeAt(i);\n    }\n\n    // Construct WAV header (similar to your Python function)\n    const sampleRate = 24000; // 24kHz\n    const numChannels = 1; // Mono\n    const bitsPerSample = 16;\n    const byteRate = sampleRate * numChannels * (bitsPerSample / 8);\n    const blockAlign = numChannels * (bitsPerSample / 8);\n    const wavSize = byteArrays.length + 36;\n    \n    // Create the WAV header\n    const wavHeader = new Uint8Array(44);\n    const view = new DataView(wavHeader.buffer);\n\n    // RIFF header\n    let offset = 0;\n    for (let i = 0; i < 4; i++) view.setUint8(offset++, \"RIFF\".charCodeAt(i));\n    view.setUint32(offset, wavSize, true); offset += 4;\n    for (let i = 0; i < 4; i++) view.setUint8(offset++, \"WAVE\".charCodeAt(i));\n\n    // fmt chunk\n    for (let i = 0; i < 4; i++) view.setUint8(offset++, \"fmt \".charCodeAt(i));\n    view.setUint32(offset, 16, true); offset += 4; // Subchunk1Size (16 for PCM)\n    view.setUint16(offset, 1, true); offset += 2;  // AudioFormat (1 for PCM)\n    view.setUint16(offset, numChannels, true); offset += 2;  // NumChannels\n    view.setUint32(offset, sampleRate, true); offset += 4;  // SampleRate\n    view.setUint32(offset, byteRate, true); offset += 4;  // ByteRate\n    view.setUint16(offset, blockAlign, true); offset += 2;  // BlockAlign\n    view.setUint16(offset, bitsPerSample, true); offset += 2;  // BitsPerSample\n\n    // data chunk\n    for (let i = 0; i < 4; i++) view.setUint8(offset++, \"data\".charCodeAt(i));\n    view.setUint32(offset, byteArrays.length, true); offset += 4;\n\n    // Combine WAV header and raw audio data\n    const wavBlob = new Blob([wavHeader, byteArrays], { type: \"audio/wav\" });\n    const audioUrl = URL.createObjectURL(wavBlob);\n\n    return audioUrl;\n}\n\nexport {base64LPCM };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}